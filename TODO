(See also: embedded TODO items in each file.)

config/* tests:
==============

We need to verify that the configs that go into configs/ are:

 a) syntactically good json (or python, eventually).
 b) present a well-formed config
 c) are acceptable for the script(s) they're designed for (this will require
    more info, like a config dtd equivalent, for what's optional and what's
    required and what format they will be.)


Cross-platform tests
====================

I'm developing on OSX and running pretty much on linux.
I want mozharness to be usable on Windows, however.

That doesn't mean that every single script needs to be runnable on Windows;
linux- or osx- specific scripts can be as platform-specific as they want
to be.

What I want x-platform tests for is lib/base/* and anything else where we
want to support Windows.


self.config audit
=================

We can end up putting stuff into our configs that ends up being orphaned,
and we'll never know without a lot of digging.

"Will changing config['option1'] do what I want? Will it break anything?
 Will it *do* anything? What script(s) actually use this config key/value
 pair?"

Something I want is a self.config audit.  Basically:

a) these are the list of all configs that get set by either script-defaults,
   command line, or config files for this family of scripts and config files.
b) this is how often each one gets called, and by which scripts
   (and what method?)
c) look at the list and prune the unneeded config options.

There may be a python tool that can do this that I don't know about.
Also, since self.config is always a ReadOnlyDict, we could either modify
that or subclass it (or w/e) to tally up whenever one of the config dict's
keys/values are referenced.


Auto-run
========

This should be simple, but I haven't figured it out yet.
How do I get every script to automatically self.run() then self.summary()?
I'd usually put it in BaseScript.__init__() at the end, but then I can't
fix things in child __init__() functions.

Maybe BaseScript.__init__() needs to self.additionalConfiguration(),
self.run(), self.summary().  Kinda ugly.  So is calling self.run()
and self.summary() in every child script.

I'm hoping for an elegant solution but will not be surprised if there isn't
one.


Style fascist
=============

We should be able to write a unit test that parses all python and config
files for coding style, shouldn't we?

 * four space indents
 * variable/action/function name styles
 * no trailing whitespace !!!
  * no dos line endings !!!
 * vim fold markers as appropriate

This could both be written in mozharness and used to keep mozharness'
coding style uniform.  If this is config-file driven, then config files
could be written for other code projects for their specific coding style
rules.

We probably need to be wary of binary files and have options for allowing
for certain brokenness in style in specific files.


TODO collator
=============

There's this file, and then there are TODOs sprinkled throughout this and
many other projects.

A simple project could be to gather all of those up into one TODO report,
via script.  We probably need to be able to differentiate a comment from
a non-comment in the filetype we're reading, currently text and python,
but could eventually be something else.

Bonus points for linking to bugs (config-driven, of course).

Extra bonus points for hg annotating the TODO comments by date/author/commit
link.

Extra special bonus points for making that annotation
revision-control-system-agnostic; this would be one start to the
lib/source/{mercurial,git,svn,etc.}.py modules.


Action pre-flight and post-flight checks
========================================

Mozharness splits scripts up into actions.  By default these will behave
in the pre-defined manner, but we can also skip actions and run certain
actions individually multiple times, or out of order if the script is called
multiple times.

This is very powerful, but can also lead to breakage if, say, the setup
action needs to be run before the do-everything-else action, but isn't.
Or if an action is destructive, but is then run a second time.

What I'd like is to be able to define pre-flight and post-flight checks
for actions.  If I'm going to package up my build, are there things I
can check for to make sure a compiled build is there to package?
Once I finish my packaging, are there things I can check for to make sure
that my packaging action was successful?


Automatic self.actionName() calls
=================================

If self.actions == ["action1", "action2"], we should be able to figure out
run() all by ourselves, shouldn't we?

Maybe for each actionName in self.actions, we should call self.actionName?
(or self.preFlightActionName, self.actionName, self.postFlightActionName,
 after checking to make sure each one of those exist?)

(Here's where we go ugh, there are underscores, dashes, *and* camel case!
 We'll either need to make an educated decision to change that, or a
 helper function to translate between them.)

(Where does the automatic final self.summary() fit in?)
